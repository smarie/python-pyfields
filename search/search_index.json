{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyfields","text":"<p>Define fields in python classes. Easily.</p> <p> </p> <p> </p> <p><code>pyfields</code> now has its own <code>@autoclass</code> with sensible defaults, to complement the existing <code>@autofields</code> feature! No need to import it from <code>autoclass</code> anymore.</p> <p>New <code>marshmallow-pyfields</code> project brings <code>pyfields</code> to the famous <code>marshmallow</code> ORM ecosystem!</p> <p><code>pyfields</code> provides a simple and elegant way to define fields in python classes. With <code>pyfields</code> you explicitly define all aspects of a field (default value/factory, type, validators, converters, documentation...) in a single place, and can refer to it from other places. </p> <p>It is designed with development freedom as primary target: </p> <ul> <li> <p>code segregation. Everything is in the field, not in <code>__init__</code>, not in <code>__setattr__</code>.</p> </li> <li> <p>absolutely no constraints. Your class does not need to use type hints. You can use python 2 and 3.5. Your class is not modified behind your back: <code>__init__</code> and <code>__setattr__</code> are untouched. You do not need to decorate your class. You do not need your class to inherit from anything. This is particularly convenient for mix-in classes, and in general for users wishing to stay in control of their class design.</p> </li> <li> <p>no performance loss by default. If you use <code>pyfields</code> to declare fields without adding validators nor converters, instance attributes will be replaced with a native python attribute on first access, preserving the same level of performance than what you are used to.</p> </li> </ul> <p>It provides many optional features that will make your object-oriented developments easier:</p> <ul> <li> <p>all field declarations support type hints and docstring,</p> </li> <li> <p>optional fields can have default values but also default values factories (such as \"if no value is provided, copy this other field\")</p> </li> <li> <p>adding validators and converters to a field does not require you to write complex logic nor many lines of code. This makes field access obviously slower than the default native implementation but it is done field by field and not on the whole class at once, so fast native fields can coexist with slower validated ones (segregation principle).</p> </li> <li> <p>initializing fields in your constructor is very easy and highly customizable</p> </li> <li> <p>you can automate fields creation with <code>@autofields</code> or even automatically add hash/dict/eq/repr to your class based on the fields using <code>@autoclass</code>.</p> </li> </ul> <p>Finally, it offers an API that other libraries can leverage to get the list of fields.</p> <p>If your first reaction is \"what about <code>attrs</code> / <code>dataclasses</code> / <code>pydantic</code> / <code>characteristic</code> / <code>traits</code> / <code>traitlets</code> / ...\", well all of these inspired <code>pyfields</code> a great deal, but all of these have stronger constraints on the class - which I did not want. Please have a look here for a complete list of inspirators.</p>"},{"location":"#installing","title":"Installing","text":"<pre><code>&gt; pip install pyfields\n</code></pre> <p>For advanced type checking capabilities, <code>pyfields</code> requires that <code>typeguard</code> or <code>pytypes</code> is installed. Note that type checking performance (speed) mostly depends on the choice of type checking library. Not installing any will be faster, but will not support all of the <code>typing</code> constructs. Let's install <code>typeguard</code> for now:</p> <pre><code>&gt; pip install typeguard\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>Below we show a few prototypical examples to illustrate how versatile <code>pyfields</code> is. See usage for a more detailed, step-by-step explanation of all features.</p> <p>compliance with python 2's old-style classes</p> <p>All examples in this doc assume python 3 and therefore show new-style classes without explicit inheritance of <code>object</code>, for readability. If you use python 2 do not forget to explicitly use new-style classes otherwise some features will not be available (the ones where a setter on the field is required: validation, conversion, read-only).</p>"},{"location":"#1-defining-a-field","title":"1. Defining a field","text":"<p>A field is defined as a class member using the <code>field()</code> method. The idea (not new) is that you declare in a single place all aspects related to each field. For mandatory fields you do not need to provide any argument. For optional fields, you will typically provide a <code>default</code> value or a <code>default_factory</code> (we will see that later).</p> <p>For example let's create a <code>Wall</code> class with one mandatory <code>height</code> and one optional <code>color</code> field:</p> <pre><code>from pyfields import field\n\nclass Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    color: str = field(default='white', doc=\"Color of the wall.\")\n</code></pre> <p>Compliance with python &lt; 3.6</p> <p>If you use python &lt; <code>3.6</code> you know that PEP484 type hints can not be declared as shown above. However you can provide them as type comments, or using the <code>type_hint</code> argument (recommended if you wish to use type validation).</p>"},{"location":"#a-field-vs-python-attr","title":"a - Field vs. Python attr","text":"<p>By default when you use <code>field()</code>, nothing more than a \"lazy field\" is created on your class. This field will only be activated when you access it on an instance. That means that you are free to implement <code>__init__</code> as you wish, or even to rely on the default <code>object</code> constructor to create instances:</p> <pre><code># instantiate using the default `object` constructor\nw = Wall()\n</code></pre> <p>No exception here even if we did not provide any value for the mandatory field <code>height</code> ! Although this default behaviour can look surprising, you will find that this feature is quite handy to define mix-in classes with attributes but without constructor. See mixture for discussion. Of course if you do not like this behaviour you can very easily add a constructor.</p> <p>Until it is accessed for the first time, a field is visible on an instance with <code>dir()</code> (because its definition is inherited from the class) but not with <code>vars()</code> (because it has not been initialized on the object):</p> <pre><code>&gt;&gt;&gt; dir(w)[-2:]\n['color', 'height']\n&gt;&gt;&gt; vars(w)\n{}\n</code></pre> <p>As soon as you access it, a field is replaced with a standard native python attribute, visible in <code>vars</code>:</p> <pre><code>&gt;&gt;&gt; w.color  # optional field: the default value is used on first 'read' access\n'white'\n\n&gt;&gt;&gt; vars(w)\n{'color': 'white'}\n</code></pre> <p>Of course mandatory fields must be initialized:</p> <pre><code>&gt;&gt;&gt; w.height  # trying to read an uninitialized mandatory field\npyfields.core.MandatoryFieldInitError: \\\n   Mandatory field 'height' has not been initialized yet on instance &lt;...&gt;.\n\n&gt;&gt;&gt; w.height = 12  # initializing mandatory field explicitly\n&gt;&gt;&gt; vars(w)\n{'color': 'white', 'height': 12}\n</code></pre> <p>Your IDE (e.g. PyCharm) should recognize the name and type of the field, so you can already refer to it easily from other code using autocompletion:</p> <p></p>"},{"location":"#b-default-value-factory","title":"b - Default value factory","text":"<p>We have seen above how to define an optional field by providing a default value. The behaviour with default values is the same than python's default: the same value is used for all objects. Therefore if your default value is a mutable object (e.g. a list) you should not use this mechanism, otherwise the same value will be shared by all instances that use the default:</p> <pre><code>class BadPocket:\n    items = field(default=[])\n\n&gt;&gt;&gt; p = BadPocket()\n&gt;&gt;&gt; p.items.append('thing')\n&gt;&gt;&gt; p.items\n['thing']\n\n&gt;&gt;&gt; g = BadPocket()\n&gt;&gt;&gt; g.items\n['thing']   # &lt;--- this is not right ! \n</code></pre> <p>To cover this use case and many others, you can use a \"default value factory\". A default value factory is a callable with a single argument: the object instance. It will be called everytime a default value is needed for a field on an object. You can either provide your own in the constructor:</p> <pre><code>class Pocket:\n    items = field(default_factory=lambda obj: [])\n</code></pre> <p>or use the provided <code>@&lt;field&gt;.default_factory</code> decorator:</p> <pre><code>class Pocket:\n    items = field()\n\n    @items.default_factory\n    def default_items(self):\n        return []\n</code></pre> <p>Finally, you can use the following built-in helper functions to cover most common cases:</p> <ul> <li><code>copy_value(&lt;value&gt;)</code> returns a factory that will create copies of the value</li> <li><code>copy_field(&lt;field_or_name&gt;)</code> returns a factory that will create copies of the given object field</li> <li><code>copy_attr(&lt;attr_name&gt;)</code> returns a factory that will create copies of the given object attribute (not necessary a field)</li> </ul>"},{"location":"#c-read-only-fields","title":"c - Read-only fields","text":"<p>You can define fields that can only be set once:</p> <pre><code>class User:\n    name = field(read_only=True)\n\nu = User()\nu.name = \"john\"\nprint(\"name: %s\\n\" % u.name)\nu.name = \"john2\"\n</code></pre> <p>yields</p> <pre><code>name: john\n\npyfields.core.ReadOnlyFieldError: Read-only field '&lt;...&gt;.User.name' has already been initialized on instance &lt;&lt;...&gt;.User object at 0x000001CA70FA25F8&gt; and cannot be modified anymore.\n</code></pre> <p>Of course this makes more sense when an appropriate constructor is defined on the class as we'll see below, but it also works independently.</p> <p>Optional fields can also be \"read-only\" of course. But remember that in that case, reading the field on a brand new object will assign it to its default value - therefore is will not modifiable anymore:</p> <pre><code>class User:\n    name = field(read_only=True, default=\"dummy\")\n\nu = User()\nprint(\"name: %s\\n\" % u.name)\nu.name = \"john\"\n</code></pre> <p>yields</p> <pre><code>name: dummy\n\npyfields.core.ReadOnlyFieldError: Read-only field '&lt;...&gt;.User.name' has already been initialized on instance &lt;&lt;...&gt;.User object at 0x000001ED05E22CC0&gt; and cannot be modified anymore.\n</code></pre> <p>In practice if you have your own constructor or if you generate one using the methods below, it will work without problem. But when debugging your constructor with an IDE that automatically calls \"repr\" on your object you might have to remember it and take extra care.</p>"},{"location":"#d-type-validation","title":"d - Type validation","text":"<p>You can add type validation to a field by setting <code>check_type=True</code>.</p> <pre><code>class Wall:\n    height: int = field(check_type=True, doc=\"Height of the wall in mm.\")\n    color: str = field(check_type=True, default='white', doc=\"Color of the wall.\")\n</code></pre> <p>yields</p> <pre><code>&gt;&gt;&gt; w = Wall()\n&gt;&gt;&gt; w.height = 1\n&gt;&gt;&gt; w.height = '1'\nTypeError: Invalid value type provided for 'Wall.height'. \\ \n  Value should be of type 'int'. Instead, received a 'str': '1'\n</code></pre> <p>By default the type used for validation is the one provided in the annotation. If you use python &lt; <code>3.6</code> or wish to override the annotation, you can explicitly fill the <code>type_hint</code> argument in <code>field()</code>. It supports both a single type or an iterable of alternate types (e.g. <code>(int, str)</code>). Note that PEP484 type comments are not taken into account - indeed it is not possible for python code to access type comments without source code inspection.</p> <p>PEP484 <code>typing</code> support</p> <p>Now type hints relying on the <code>typing</code> module (PEP484) are correctly checked using whatever 3d party type checking library is available (<code>typeguard</code> is first looked for, then <code>pytypes</code> as a fallback). If none of these providers are available, a fallback implementation is provided, basically flattening <code>Union</code>s and replacing <code>TypeVar</code>s before doing <code>is_instance</code>. It is not guaranteed to support all <code>typing</code> subtleties.</p>"},{"location":"#e-nonable-fields","title":"e - Nonable fields","text":"<p>Definition</p> <p>A nonable field is a field that can be set to <code>None</code>. It can be mandatory, or optional. By default, <code>pyfields</code> tries to guess if a field is nonable :</p> <ul> <li> <p>if a type hint is provided and it is PEP484 <code>typing.Optional[...]</code>, then this explicitly means that the fields is nonable. (Note: the choice of this name <code>Optional</code> is terrible but it is like that, see this discussion</p> </li> <li> <p>if the field is optional with a default value of <code>None</code>, then this implicitly means that the field is nonable. This is not the recommended way anymore but it has the advantage of being compact, so it is supported by <code>pyfields</code>.</p> </li> <li> <p>in all other cases, <code>pyfields</code> can not really tell and sets the field to nonable=UNKNOWN. </p> </li> </ul> <p>You can override this behaviour by explicitly stating <code>field(nonable=True)</code> or <code>field(nonable=False)</code>.</p> <p>See also this stack overflow answer.</p> <p>Effect</p> <p>When a field is known to be nonable, all of its type checks and validators are skipped when <code>None</code> is received.</p> <p>When a field is forced explicitly to <code>nonable=False</code>, by default nothing happens, this is just declarative. However as soon as the field has type checking or validation activated, then a <code>NoneError</code> will be raised when <code>None</code> is received.</p>"},{"location":"#f-value-validation","title":"f - Value validation","text":"<p>You can add value (and type) validation to a field by providing <code>validators</code>. <code>pyfields</code> relies on <code>valid8</code> for validation, so the basic definition of a validation function is the same: it should be a <code>&lt;callable&gt;</code> with signature <code>f(value)</code>, returning <code>True</code> or <code>None</code> in case of success. </p> <p>A validator consists in a base validation function, with an optional error message and an optional failure type. To specify all these elements, the supported syntax is the same than in <code>valid8</code>:</p> <ul> <li> <p>For a single validator, either provide a <code>&lt;callable&gt;</code> or a tuple <code>(&lt;callable&gt;, &lt;error_msg&gt;)</code>, <code>(&lt;callable&gt;, &lt;failure_type&gt;)</code> or <code>(&lt;callable&gt;, &lt;error_msg&gt;, &lt;failure_type&gt;)</code>. See here for details.</p> </li> <li> <p>For several validators, either provide a list or a dictionary. See here for details.</p> </li> </ul> <p>An example is probably better to picture this:</p> <pre><code>from mini_lambda import x\nfrom valid8.validation_lib import is_in\n\ncolors = {'white', 'blue', 'red'}\n\nclass Wall:\n    height: int = field(validators={'should be a positive number': x &gt; 0,\n                                    'should be a multiple of 100': x % 100 == 0}, \n                        doc=\"Height of the wall in mm.\")\n    color: str = field(validators=is_in(colors), \n                       default='white', \n                       doc=\"Color of the wall.\")\n</code></pre> <p>yields</p> <pre><code>&gt;&gt;&gt; w = Wall()\n&gt;&gt;&gt; w.height = 100\n&gt;&gt;&gt; w.height = 1\nvalid8.entry_points.ValidationError[ValueError]: \n    Error validating [&lt;...&gt;.Wall.height=1]. \n    At least one validation function failed for value 1. \n    Successes: ['x &gt; 0'] / Failures: {\n      'x % 100 == 0': 'InvalidValue: should be a multiple of 100. Returned False.'\n    }.\n&gt;&gt;&gt; w.color = 'magenta'\nvalid8.entry_points.ValidationError[ValueError]: \n    Error validating [&lt;...&gt;.Wall.color=magenta]. \n    NotInAllowedValues: x in {'blue', 'red', 'white'} does not hold \n    for x=magenta. Wrong value: 'magenta'.\n</code></pre> <p>For advanced validation scenarios you might with your validation callables to receive a bit of context. <code>pyfields</code> supports that the callables accept one, two or three arguments for this (where <code>valid8</code> supports only 1): <code>f(val)</code>, <code>f(obj, val)</code>, and <code>f(obj, field, val)</code>.</p> <p>For example we can define walls where the width is a multiple of the length:</p> <pre><code>from valid8 import ValidationFailure\n\nclass InvalidWidth(ValidationFailure):\n    help_msg = 'should be a multiple of the height ({height})'\n\ndef validate_width(obj, width):\n    if width % obj.height != 0:\n        raise InvalidWidth(width, height=obj.height)\n\nclass Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    width: str = field(validators=validate_width,\n                       doc=\"Width of the wall in mm.\")\n</code></pre> <p>Finally, in addition to the above syntax, <code>pyfields</code> support that you add validators to a field after creation, using the <code>@field.validator</code> decorator:</p> <pre><code>class Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    width: str = field(doc=\"Width of the wall in mm.\")\n\n    @width.validator\n    def width_is_proportional_to_height(self, width_value):\n        if width_value % self.height != 0:\n            raise InvalidWidth(width_value, height=self.height)\n</code></pre> <p>As for all validators, the signature of the decorated function should be either <code>(value)</code>, <code>(obj/self, value)</code>, or <code>(obj/self, field, value)</code>.</p> <p>Several such decorators can be applied on the same function, so as to mutualize implementation. In that case, you might wish to use the signature with 3 arguments so as to easily debug which field is being validated:</p> <pre><code>class Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    width: str = field(doc=\"Width of the wall in mm.\")\n\n    @height.validator\n    @width.validator\n    def width_is_proportional_to_height(self, width_value):\n        if width_value % self.height != 0:\n            raise InvalidWidth(width_value, height=self.height)\n</code></pre> <p>See <code>API reference</code> for details on <code>@&lt;field&gt;.validator</code>.</p> <p>See <code>valid8</code> documentation for details about the syntax and available validation lib.</p>"},{"location":"#g-converters","title":"g - Converters","text":"<p>You can add converters to a field by providing <code>converters</code>. </p> <p>A <code>Converter</code> consists in a conversion function, with an optional name, and an optional acceptance criterion. </p> <ul> <li> <p>The conversion function should be a callable with signature <code>f(value)</code>, <code>f(obj/self, value)</code>, or <code>f(obj/self, field, value)</code>, returning the converted value in case of success and raising an exception in case of converion failure. </p> </li> <li> <p>The optional acceptance criterion can be a type, or a callable. When a type is provided, <code>isinstance</code> is used as the callable. The definition for the callable is exactly the same than for validation callables, see previous section. In addition, one can use a wildcard <code>'*'</code> or <code>None</code> to denote \"accept everything\". In that case acceptance is basically reduced to the conversion function raising exceptions when it can not convert values.</p> </li> </ul> <p>To add converters on a field using <code>field(converters=...)</code>, the supported syntax is the following:</p> <ul> <li> <p>For a single converter, either provide a <code>Converter</code>, a <code>&lt;conversion_callable&gt;</code>, a tuple <code>(&lt;accepted_type&gt;, &lt;conversion_callable&gt;)</code>, or a tuple <code>(&lt;acceptance_callable&gt;, &lt;conversion_callable&gt;)</code>. </p> </li> <li> <p>For several converters, either provide a list of elements above, or a dictionary. In case of a dictionary, the key is <code>&lt;accepted_type&gt;</code>/<code>&lt;acceptance_callable&gt;</code>, and the value is <code>&lt;conversion_callable&gt;</code>.</p> </li> </ul> <p>For example</p> <pre><code>from pyfields import field\nclass Foo:\n    f = field(type_hint=int, converters=int)\n    g = field(type_hint=int, converters={str: lambda s: len(s), \n                                         '*': int})\n</code></pre> <p>When a new value is set on a field, all of its converters are first scanned in order. Everytime a converter accepts a value, it is applied to convert it. The process stops at the first successful conversion, or after all converters have been tried. The obtained value (either the original one or the converted one) is then passed as usual to the validators (see previous section).</p> <p>As for validators, you can easily define converters using a decorator <code>@&lt;field&gt;.converter</code>. As for all converters, the signature of the decorated function should be either <code>(value)</code>, <code>(obj/self, value)</code>, or <code>(obj/self, field, value)</code>.</p> <p>Several such decorators can be applied on the same function, so as to mutualize implementation. In that case, you might wish to use the signature with 3 arguments so as to easily debug which field is being validated:</p> <pre><code>class Foo:\n    m = field(type_hint=int, check_type=True)\n    m2 = field(type_hint=int, check_type=True)\n\n    @m.converter(accepts=str)\n    @m2.converter\n    def from_anything(self, field, value):\n        print(\"converting a value for %s\" % field.qualname)\n        return int(value)\n</code></pre> <p>You can check that everything works as expected:</p> <pre><code>&gt;&gt;&gt; o = Foo()\n&gt;&gt;&gt; o.m2 = '12'\nconverting a value for Foo.m2\n&gt;&gt;&gt; o.m2 = 1.5\nconverting a value for Foo.m2\n&gt;&gt;&gt; o.m = 1.5  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nTypeError: Invalid value type provided for 'Foo.m'. Value should be of type &lt;class 'int'&gt;.\n  Instead, received a 'float': 1.5\n</code></pre> <p>Finally since debugging conversion issues might not be straightforward, a special <code>trace_convert</code> function is provided to output details about the outcome of each converter's acceptance and conversion step. This function is also available as a method of the field objects (obtained from the class).</p> <pre><code>m_field = Foo.__dict__['m']\nconverted_value, details = m_field.trace_convert(1.5)\nprint(details)\n</code></pre>"},{"location":"#h-native-vs-descriptor","title":"h - Native vs. Descriptor","text":"<p><code>field()</code> by default creates a so-called native field. This special construct is designed to be as fast as a normal python attribute after the first access, so that performance is not impacted. This high level of performance has a drawback: validation and conversion are not possible on a native field. </p> <p>So when you add type or value validation, or conversion, to a field, <code>field()</code> will automatically create a descriptor field instead of a native field. This is an object relying on the python descriptor protocol. Such objects have slower access time than native python attributes but provide convenient hooks necessary to perform validation and conversion.</p> <p>For experiments, you can force a field to be a descriptor by setting <code>native=False</code>:</p> <pre><code>from pyfields import field\n\nclass Foo:\n    a = field()               # a native field\n    b = field(native=False)   # a descriptor field\n</code></pre> <p>We can easily see the difference (note: direct class access <code>Foo.a</code> is currently forbidden because of this issue):</p> <pre><code>&gt;&gt;&gt; Foo.__dict__['a']\n&lt;NativeField: &lt;...&gt;.Foo.a&gt;\n\n&gt;&gt;&gt; Foo.__dict__['b']\n&lt;DescriptorField: &lt;...&gt;.Foo.a&gt;\n</code></pre> <p>And measure the difference in access time:</p> <pre><code>import timeit\n\nf = Foo()\n\ndef set_a(): f.a = 12\n\ndef set_b(): f.b = 12\n\ndef set_c(): f.c = 12\n\nta = timeit.Timer(set_a).timeit()\ntb = timeit.Timer(set_b).timeit()\ntc = timeit.Timer(set_c).timeit()\n\nprint(\"Average time (ns) setting the field:\")\nprint(\"%0.2f (normal python) ; %0.2f (native field) ;\" \n      \" %0.2f (descriptor field)\" % (tc, ta, tb))\n</code></pre> <p>yields (results depend on your machine):</p> <pre><code>Average time (ns) setting the field:\n0.09 (normal python) ; 0.09 (native field) ; 0.44 (descriptor field)\n</code></pre> <p>Why are native fields so fast ?</p> <p>Native fields are implemented as a \"non-data\" python descriptor that overrides itself on first access. So the first time the attribute is read, a small python method call extra cost is paid but the attribute is immediately replaced with a normal attribute inside the object <code>__dict__</code>. That way, subsequent calls use native python attribute access without overhead. This trick was inspired by werkzeug's @cached_property.</p> <p>Adding validators or converters to native fields</p> <p>If you run python <code>3.6</code> or greater and add validators or converters after field creation (typically using decorators), <code>field</code> will automatically replace the native field with a descriptor field. However with older python versions this is not always possible, so it is recommended that you explicitly state <code>native=False</code>.</p>"},{"location":"#2-adding-a-constructor","title":"2. Adding a constructor","text":"<p><code>pyfields</code> provides you with several alternatives to add a constructor to a class equipped with fields. The reason why we do not follow the Zen of python here (\"There should be one-- and preferably only one --obvious way to do it.\") is to recognize that different developers may have different coding style or philosophies, and to be as much as possible agnostic in front of these.</p>"},{"location":"#a-make_init","title":"a - <code>make_init</code>","text":"<p><code>make_init</code> is the most compact way to add a constructor to a class with fields. With it you create your <code>__init__</code> method in one line:</p> <pre><code>from pyfields import field, make_init\n\nclass Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    color: str = field(default='white', doc=\"Color of the wall.\")\n__init__ = make_init()\n</code></pre> <p>By default, all fields will appear in the constructor, in the order of appearance in the class and its parents, following the <code>mro</code> (method resolution order, the order in which python looks for a method in the hierarchy of classes). Since it is not possible for mandatory fields to appear after optional fields in the signature, all mandatory fields will appear first, and then all optional fields will follow.</p> <p>The easiest way to see the result is probably to look at the help on your class:</p> <pre><code>&gt;&gt;&gt; help(Wall)\nHelp on class Wall in module &lt;...&gt;:\n\nclass Wall(builtins.object)\n |  Wall(height, color='white')\n |  (...)\n</code></pre> <p>or you can inspect the method:</p> <pre><code>&gt;&gt;&gt; help(Wall.__init__)\nHelp on function __init__ in module &lt;...&gt;:\n\n__init__(self, height, color='white')\n    The `__init__` method generated for you when you use `make_init`\n</code></pre> <p>You can check that your constructor works as expected:</p> <pre><code>&gt;&gt;&gt; w = Wall(2)\n&gt;&gt;&gt; vars(w)\n{'color': 'white', 'height': 2}\n\n&gt;&gt;&gt; w = Wall(color='blue', height=12)\n&gt;&gt;&gt; vars(w)\n{'color': 'blue', 'height': 12}\n\n&gt;&gt;&gt; Wall(color='blue')\nTypeError: __init__() missing 1 required positional argument: 'height'\n</code></pre> <p>If you do not wish the generated constructor to expose all fields, you can customize it by providing an explicit ordered list of fields. For example below only <code>height</code> will be in the constructor:</p> <pre><code>from pyfields import field, make_init\n\nclass Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n    color: str = field(default='white', doc=\"Color of the wall.\")\n\n    # only `height` will be in the constructor\n__init__ = make_init(height)\n</code></pre> <p>The list can contain fields defined in another class, typically a parent class: </p> <pre><code>from pyfields import field, make_init\n\nclass Wall:\n    height: int = field(doc=\"Height of the wall in mm.\")\n\nclass ColoredWall(Wall):\n    color: str = field(default='white', doc=\"Color of the wall.\")\n    __init__ = make_init(Wall.height)\n</code></pre> <p>Note: a pending issue prevents the above example to work, you have to use <code>Wall.__dict__['height']</code> instead of <code>Wall.height</code> to reference the field from the other class.</p> <p>Finally, you can customize the created constructor by declaring a post-init method as the <code>post_init_fun</code> argument. This is roughly equivalent to <code>@init_fields</code> so we do not present it here, see documentation.</p>"},{"location":"#b-init_fields","title":"b - <code>@init_fields</code>","text":"<p>If you prefer to write an init function as usual, you can use the <code>@init_fields</code> decorator to augment this init function's signature with all or some fields.</p> <pre><code>from pyfields import field, init_fields\n\nclass Wall:\n    height = field(doc=\"Height of the wall in mm.\")  # type: int\n    color = field(default='white', doc=\"Color of the wall.\")  # type: str\n\n@init_fields\ndef __init__(self, msg='hello'):\n\"\"\"\n        Constructor. After initialization, some print message is done\n\n        :param msg: the message details to add\n        \"\"\"\n        print(\"post init ! height=%s, color=%s, msg=%s\" % (self.height, self.color, msg))\n        self.non_field_attr = msg\n</code></pre> <p>Note: as you can see in this example, you can of course create other attributes in this init function (done in the last line here with <code>self.non_field_attr = msg</code>). Indeed, declaring fields in a class do not \"pollute\" the class, so you can do anything you like as usual.</p> <p>You can check that the resulting constructor works as expected:</p> <pre><code>&gt;&gt;&gt; help(Wall)\nHelp on class Wall in module &lt;...&gt;:\nclass Wall(builtins.object)\n |  Wall(height, msg='hello', color='white')\n...\n\n&gt;&gt;&gt; w = Wall(1, 'hey')\npost init ! height=1, color=white, msg=hey\n\n&gt;&gt;&gt; vars(w)\n{'height': 1, 'color': 'white', 'non_field_attr': 'hey'}\n</code></pre> <p>Note on the order of arguments in the resulting <code>__init__</code> signature: as you can see, <code>msg</code> appears between <code>height</code> and <code>color</code> in the signature. This is because all mandatory arguments appear first, then the optionals - and within each group, the user-provided ones (e.g. <code>msg</code>) appear first. You can change this behaviour by setting <code>init_args_before=False</code>. See API reference for details.</p>"},{"location":"#3-simplifying","title":"3. Simplifying","text":""},{"location":"#a-autofields","title":"a - <code>@autofields</code>","text":"<p>Do you think that the above is still too verbose to define a class ? You can use <code>@autofields</code> to create fields and the constructor for you :</p> <pre><code>from pyfields import autofields\nfrom typing import List\n\n@autofields\nclass Item:\n    name: str\n\n@autofields\nclass Pocket:\n    size: int\n    items: List[Item] = []\n\n# test that the constructor works correctly\np = Pocket(size=2)\nassert p.size == 2\np.items.append(Item(name=\"a_name\"))\n</code></pre> <p>Note that members that are already fields are not further transformed. Therefore you can still use <code>field()</code> on some members, for example if you need to specify custom validators, converters, or default factory.</p> <p><code>@autofields</code> is just syntactic sugar for <code>field()</code> and <code>make_init()</code> - for example the <code>Pocket</code> class defined above is completely equivalent to: </p> <pre><code>from pyfields import field, copy_value, make_init\n\nclass Pocket:\n    size = field(type_hint=int)\n    items = field(type_hint=List[Item], \n                  default_factory=copy_value([]))\n    __init__ = make_init()\n</code></pre> <p>By default type checking is not enabled on the generated fields, but you can enable it with <code>@autofields(check_types=True)</code>. You can also disable constructor creation with <code>@autofields(make_init=False)</code>. See API reference for details.</p>"},{"location":"#b-autoclass","title":"b - <code>@autoclass</code>","text":"<p>Do you also wish to have <code>hash</code>, <code>dict</code>, <code>eq</code>, and <code>repr</code> views automatically created for your class ? From version <code>1.6</code> on, <code>pyfields</code> provides an <code>@autoclass</code> decorator. That way, your field definitions can directly be reused for most of the class behaviour.</p> <pre><code>from pyfields import field, autoclass\n\n@autoclass\nclass Foo:\n    msg: str\n    age: int = 12\n    height: int = field(default=50)\n\nfoo = Foo(msg='hello')\n\nprint(foo)              # automatic string representation\nprint(foo.to_dict())    # automatic from/to dict\nassert foo == Foo.from_dict(foo.to_dict())\n\nassert foo == Foo(msg='hello', age=12, height=50)        # automatic equality comparison \nassert foo == {'msg': 'hello', 'age': 12, 'height': 50}  # automatic eq comparison with dicts\n</code></pre> <p>yields</p> <pre><code>Foo(msg='hello', age=12, height=50)\n{'msg': 'hello', 'age': 12, 'height': 50}\n</code></pre> <p>use pyfields <code>@autoclass</code> over the one in <code>autoclass</code> library</p> <p>This decorator combines <code>@autofields</code> and <code>@autoclass</code> into one, with options that are relevant to <code>pyfields</code>. Therefore it is now the recommended one to use.</p> <p>See API reference for details.</p>"},{"location":"#c-vtypes","title":"c - <code>VType</code>s","text":"<p>Instead of registering validators in the field, you can now use <code>vtypes</code>. That way, everything is in the type: type checking AND value validation. </p> <pre><code>from pyfields import field\nfrom vtypes import VType\n\nclass NonEmpty(VType):\n\"\"\"A 'non empty' validation type\"\"\"\n    __validators__ = {'should be non empty': lambda x: len(x) &gt; 0}\n\nclass NonEmptyStr(NonEmpty, str):\n\"\"\"A 'non empty string' validation type\"\"\"\n    pass\n\nclass Item:\n    name: NonEmptyStr = field(doc=\"the field name\")\n</code></pre> <p>Of course you can combine it with <code>@autofields</code> - do not forget <code>check_types=True</code> so that typechecking is enabled:</p> <pre><code>from pyfields import autofields\n\n@autofields(check_types=True)\nclass Item:\n    name: NonEmptyStr\n</code></pre> <p><code>pytypes</code> does not currently support <code>vtype</code> so in order to benefit from this feature, you should either install <code>typeguard</code> or uninstall <code>pytypes</code> (to let the default <code>pyfields</code> type checker take over). See this issue.</p>"},{"location":"#4-misc","title":"4. Misc.","text":""},{"location":"#api","title":"API","text":"<p><code>pyfields</code> offers an API so that other libraries can inspect the fields: <code>get_fields</code>, <code>yield_fields</code>, <code>has_fields</code>, <code>get_field</code>. See API reference for details.</p>"},{"location":"#slots","title":"Slots","text":"<p>You can use <code>pyfields</code> if your class has <code>__slots__</code>. You will simply have to use an underscore in the slot name corresponding to a field: <code>_&lt;field_name&gt;</code>. For example:</p> <pre><code>class WithSlots:\n    __slots__ = ('_a',)\n    a = field()\n</code></pre> <p>Since from python documentation, \"class attributes cannot be used to set default values for instance variables defined by <code>__slots__</code>\", native fields are not supported with <code>__slots__</code>. If you run python <code>3.6</code> or greater, <code>field</code> will automatically detect that a field is used on a class with <code>__slots__</code> and will replace the native field with a descriptor field. However with older python versions this is not always possible, so it is recommended that you explicitly state <code>native=False</code>.</p> <p>Note that if your class is a dual class (meaning that it declares a slot named <code>__dict__</code>), then native fields are supported and you do not have anything special to do (not even declaring a slot for the field).</p>"},{"location":"#main-features-benefits","title":"Main features / benefits","text":"<p>See top of the page</p>"},{"location":"#see-also","title":"See Also","text":"<p>This library was inspired by:</p> <ul> <li><code>werkzeug.cached_property</code></li> <li><code>attrs</code></li> <li><code>dataclasses</code></li> <li><code>autoclass</code></li> <li><code>pydantic</code></li> </ul>"},{"location":"#others","title":"Others","text":"<p>Do you like this library ? You might also like my other python libraries </p>"},{"location":"#want-to-contribute","title":"Want to contribute ?","text":"<p>Details on the github page: https://github.com/smarie/python-pyfields</p>"},{"location":"api_reference/","title":"API reference","text":"<p>In general, <code>help(symbol)</code> will provide the latest up-to-date documentation.</p>"},{"location":"api_reference/#field","title":"<code>field</code>","text":"<pre><code>def field(type_hint=None,        # type: Type[T]\n          check_type=False,      # type: bool\n          default=EMPTY,         # type: T\n          default_factory=None,  # type: Callable[[], T]\n          validators=None,       # type: Validators\n          doc=None,              # type: str\n          name=None,             # type: str\n          native=None            # type: bool\n          ):\n    # type: (...) -&gt; T\n</code></pre> <p>Returns a class-level attribute definition. It allows developers to define an attribute without writing an  <code>__init__</code> method. Typically useful for mixin classes.</p> <p>Laziness</p> <p>The field will be lazily-defined, so if you create an instance of the class, the field will not have any value  until it is first read or written.</p> <p>Optional/Mandatory</p> <p>By default fields are mandatory, which means that you must set them before reading them (otherwise a <code>MandatoryFieldInitError</code> will be raised). You can define an optional field by providing a <code>default</code> value. This value will not be copied but used \"as is\" on all instances, following python's classical pattern for default values. If you wish to run specific code to instantiate the default value, you may provide a <code>default_factory</code> callable instead. That callable should have no mandatory argument and should return the default value. Alternately you can use the <code>@&lt;field&gt;.default_factory</code> decorator.</p> <p>Typing</p> <p>Type hints for fields can be provided using the standard python typing mechanisms (type comments for python &lt; 3.6 and class member type hints for python &gt;= 3.6). Types declared this way will not be checked at runtime, they are just hints for the IDE. You can also specify a <code>type_hint</code> explicitly to override the type hints gathered from the other means indicated above. It supports both a single type or an iterable of alternate types (e.g. <code>(int, str)</code>). The corresponding type hint is automatically declared by <code>field</code> so your IDE will know about it. Specifying a <code>type_hint</code> explicitly is mostly useful if you are running python &lt; 3.6 and wish to use type validation, see below.</p> <p>By default <code>check_type</code> is <code>False</code>. This means that the abovementioned <code>type_hint</code> is just a hint. If you set <code>check_type=True</code> the type declared in the type hint will be validated, and a <code>TypeError</code> will be raised if provided values are invalid. Important: if you are running python &lt; 3.6 you have to set the type hint explicitly using <code>type_hint</code> if you wish to set <code>check_type=True</code>, otherwise you will get an exception. Indeed type comments can not be collected by the code.</p> <p>Now type hints relying on the <code>typing</code> module (PEP484) are correctly checked using whatever 3d party type checking library is available (<code>typeguard</code> is first looked for, then <code>pytypes</code> as a fallback). If none of these providers are available, a fallback implementation is provided, basically flattening <code>Union</code>s and replacing <code>TypeVar</code>s before doing <code>is_instance</code>. It is not guaranteed to support all <code>typing</code> subtleties.</p> <p>Documentation</p> <p>A docstring can be provided in <code>doc</code>for code readability.</p> <p>Example</p> <pre><code>&gt;&gt;&gt; from pyfields import field\n&gt;&gt;&gt; class Foo(object):\n...     od = field(default='bar', doc=\"This is an optional field with a default value\")\n...     odf = field(default_factory=lambda obj: [], doc=\"This is an optional with a default value factory\")\n...     m = field(doc=\"This is a mandatory field\")\n...     mt: int = field(check_type=True, doc=\"This is a type-checked mandatory field\")\n...\n&gt;&gt;&gt; o = Foo()\n&gt;&gt;&gt; o.od   # read access with default value\n'bar'\n&gt;&gt;&gt; o.odf  # read access with default value factory\n[]\n&gt;&gt;&gt; o.odf = 12  # write access\n&gt;&gt;&gt; o.odf\n12\n&gt;&gt;&gt; o.m  # read access for mandatory attr without init\nTraceback (most recent call last):\n    ...\npyfields.core.MandatoryFieldInitError: Mandatory field 'm' has not been initialized yet on instance...\n&gt;&gt;&gt; o.m = True\n&gt;&gt;&gt; o.m  # read access for mandatory attr after init\nTrue\n&gt;&gt;&gt; del o.m  # all attributes can be deleted, same behaviour than new object\n&gt;&gt;&gt; o.m\nTraceback (most recent call last):\n    ...\npyfields.core.MandatoryFieldInitError: Mandatory field 'm' has not been initialized yet on instance...\n&gt;&gt;&gt; o.mt = 1\n&gt;&gt;&gt; o.mt = '1'\nTraceback (most recent call last):\n    ...\nTypeError: Invalid value type ...\n</code></pre> <p>Limitations</p> <p>Old-style classes are not supported: in python 2, don't forget to inherit from <code>object</code>.</p> <p>Performance overhead</p> <p><code>field</code> has two different ways to create your fields. One named <code>NativeField</code> is faster but does not permit type checking, validation, or converters; besides it does not work with classes using <code>__slots__</code>. It is used by default everytime where it is possible, except if you use one of the abovementioned features. In that case a <code>DescriptorField</code> will transparently be created. You can force a <code>DescriptorField</code> to be created by setting <code>native=False</code>.</p> <p>The <code>NativeField</code> class implements the \"non-data\" descriptor protocol. So the first time the attribute is read, a small  python method call extra cost is paid. But afterwards the attribute is replaced with a native attribute inside the object <code>__dict__</code>, so subsequent calls use native access without overhead.  This was inspired by werkzeug's @cached_property. </p> <p>Inspired by</p> <p>This method was inspired by </p> <ul> <li><code>@lazy_attribute</code> (sagemath)</li> <li><code>@cached_property</code> (werkzeug) and this post</li> <li>this post</li> <li><code>attrs</code> / <code>dataclasses</code></li> </ul> <p>Parameters</p> <ul> <li><code>type_hint</code>: an optional explicit type hint for the field, to override the type hint defined by PEP484 especially on old python versions because type comments can not be captured. It supports both a single type or an iterable of alternate types (e.g. <code>(int, str)</code>). By default the type hint is just a hint and does not contribute to validation. To enable type validation, set <code>check_type</code> to <code>True</code>.</li> <li><code>check_type</code>: by default (<code>check_type=False</code>), the type of a field, provided using PEP484 type hints or an explicit <code>type_hint</code>, is not validated when you assign a new value to it. You can activate type validation by setting <code>check_type=True</code>. In that case the field will become a descriptor field.</li> <li><code>default</code>: a default value for the field. Providing a <code>default</code> makes the field \"optional\". <code>default</code> value is not copied on new instances, if you wish a new copy to be created you should provide a <code>default_factory</code> instead. Only one of <code>default</code> or <code>default_factory</code> should be provided.</li> <li><code>default_factory</code>: a factory that will be called (without arguments) to get the default value for that field, everytime one is needed. Providing a <code>default_factory</code> makes the field \"optional\". Only one of <code>default</code> or <code>default_factory</code> should be provided.</li> <li><code>validators</code>: a validation function definition, sequence of validation function definitions, or dictionary of validation function definitions. See <code>valid8</code> \"simple syntax\" for details.</li> <li><code>doc</code>: documentation for the field. This is mostly for class readability purposes for now.</li> <li><code>name</code>: in python &lt; 3.6 this is mandatory if you do not use any other decorator or constructor creation on the class (such as <code>make_init</code>). If provided, it should be the same name than the one used used in the class field definition (i.e. you should define the field as <code>&lt;name&gt; = field(name=&lt;name&gt;)</code>).</li> <li><code>native</code>: a boolean that can be turned to <code>False</code> to force a field to be a descriptor field, or to <code>True</code> to force it to be a native field. Native fields are faster but can not support type and value validation nor conversions or callbacks. <code>None</code> (default) automatically sets <code>native=True</code> if no <code>validators</code> nor <code>check_type=True</code> nor <code>converters</code> are provided ; and <code>native=False</code> otherwise. In general you should not set this option manually except for experiments.</li> </ul>"},{"location":"api_reference/#fielddefault_factory","title":"<code>@&lt;field&gt;.default_factory</code>","text":"<p>Decorator to register the decorated function as the default factory of a field. Any previously registered  default factory will be overridden.</p> <p>The decorated function should accept a single argument <code>(obj/self)</code>, and should return a value to use as the default.</p> <pre><code>&gt;&gt;&gt; class Pocket:\n...     items = field()\n...\n...     @items.default_factory\n...     def default_items(self):\n...         print(\"generating default value for %s\" % self)\n...         return []\n...\n&gt;&gt;&gt; p = Pocket()\n&gt;&gt;&gt; p.items\ngenerating default value for &lt;pyfields.core.Pocket object ...\n[]\n</code></pre> <p>Several helper functions are available to create default factories:</p> <ul> <li> <p><code>copy_value(&lt;value&gt;, deep=True, autocheck=True)</code> returns a factory that creates a copy of the provided <code>val</code> everytime it is called. Handy if you wish to use mutable objects as default values for your fields ; for example lists. Not that starting in version 1.7, <code>copy_value</code> will automatically check that the (deep) copy operation is feasible, at initial call time. You can disable this by setting <code>autocheck=False</code>.</p> </li> <li> <p><code>copy_attr(&lt;att_name&gt;, deep=True)</code> returns a factory that creates a (deep or not) copy of the value in the given attribute everytime it is called.</p> </li> <li> <p><code>copy_field(&lt;field_or_name&gt;, deep=True)</code> is similar to <code>copy_attr</code> but you can provide a <code>field</code> instead of a name.</p> </li> </ul>"},{"location":"api_reference/#fieldvalidator","title":"<code>@&lt;field&gt;.validator</code>","text":"<p>A decorator to add a validator to a field.</p> <pre><code>&gt;&gt;&gt; class Foo(object):\n...     m = field()\n...     @m.validator\n...     def m_is_positive(self, m_value):\n...         return m_value &gt; 0\n...\n&gt;&gt;&gt; o = Foo()\n&gt;&gt;&gt; o.m = 0  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nvalid8.entry_points.ValidationError[ValueError]: Error validating [Foo.m=0]. InvalidValue:\n    Function [m_is_positive] returned [False] for value 0.\n</code></pre> <p>The decorated function should have a signature of <code>(val)</code>, <code>(obj/self, val)</code>, or <code>(obj/self, field, val)</code>. It should return <code>True</code> or <code>None</code> in case of success.</p> <p>You can use several of these decorators on the same function so as to share implementation across multiple fields:</p> <pre><code>&gt;&gt;&gt; class Foo(object):\n...     m = field()\n...     m2 = field()\n...\n...     @m.validator\n...     @m2.validator\n...     def is_positive(self, field, value):\n...         print(\"validating %s\" % field.qualname)\n...         return value &gt; 0\n...\n&gt;&gt;&gt; o = Foo()\n&gt;&gt;&gt; o.m2 = 12\nvalidating Foo.m2\n&gt;&gt;&gt; o.m = 0  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n...\nvalid8.entry_points.ValidationError[ValueError]: Error validating [Foo.m=0]. InvalidValue:\n    Function [is_positive] returned [False] for value 0.\n</code></pre>"},{"location":"api_reference/#constructors","title":"Constructors","text":""},{"location":"api_reference/#make_init","title":"<code>make_init</code>","text":"<pre><code>def make_init(*fields: Union[Field, Any],\n              post_init_fun: Callable = None,\n              post_init_args_before: bool = True\n              ) -&gt; Callable:\n</code></pre> <p>Creates a constructor based on the provided fields.</p> <p>If <code>fields</code> is empty, all fields from the class will be used in order of appearance, then the ancestors (following the mro)</p> <pre><code>&gt;&gt;&gt; from pyfields import field, make_init\n&gt;&gt;&gt; class Wall:\n...     height = field(doc=\"Height of the wall in mm.\")\n...     color = field(default='white', doc=\"Color of the wall.\")\n...     __init__ = make_init()\n&gt;&gt;&gt; w = Wall(1, color='blue')\n&gt;&gt;&gt; assert vars(w) == {'color': 'blue', 'height': 1}\n</code></pre> <p>If <code>fields</code> is not empty, only the listed fields will appear in the constructor and will be initialized upon init.</p> <pre><code>&gt;&gt;&gt; class Wall:\n...     height = field(doc=\"Height of the wall in mm.\")\n...     color = field(default='white', doc=\"Color of the wall.\")\n...     __init__ = make_init(height)\n&gt;&gt;&gt; w = Wall(1, color='blue')\nTraceback (most recent call last):\n...\nTypeError: __init__() got an unexpected keyword argument 'color'\n</code></pre> <p><code>fields</code> can contain fields that do not belong to this class: typically they can be fields defined in a parent class. Note however that any field can be used, it is not mandatory to use class or inherited fields.</p> <pre><code>&gt;&gt;&gt; class Wall:\n...     height: int = field(doc=\"Height of the wall in mm.\")\n...\n&gt;&gt;&gt; class ColoredWall(Wall):\n...     color: str = field(default='white', doc=\"Color of the wall.\")\n...     __init__ = make_init(Wall.__dict__['height'])\n...\n&gt;&gt;&gt; w = ColoredWall(1)\n&gt;&gt;&gt; vars(w)\n{'height': 1}\n</code></pre> <p>If a <code>post_init_fun</code> is provided, it should be a function with <code>self</code> as first argument. This function will be executed after all declared fields have been initialized. The signature of the resulting <code>__init__</code> function created will be constructed by blending all mandatory/optional fields with the mandatory/optional args in the <code>post_init_fun</code> signature. The ones from the <code>post_init_fun</code> will appear first except if <code>post_init_args_before</code> is set to <code>False</code></p> <pre><code>&gt;&gt;&gt; class Wall:\n...     height: int = field(doc=\"Height of the wall in mm.\")\n...     color: str = field(default='white', doc=\"Color of the wall.\")\n...\n...     def post_init(self, msg='hello'):\n...         print(\"post init ! height=%s, color=%s, msg=%s\" % (self.height, self.color, msg))\n...         self.non_field_attr = msg\n...\n...     # only `height` and `foo` will be in the constructor\n...     __init__ = make_init(height, post_init_fun=post_init)\n...\n&gt;&gt;&gt; w = Wall(1, 'hey')\npost init ! height=1, color=white, msg=hey\n&gt;&gt;&gt; assert vars(w) == {'height': 1, 'color': 'white', 'non_field_attr': 'hey'}\n</code></pre> <p>Parameters</p> <ul> <li><code>fields</code>: the fields to include in the generated constructor signature. If no field is provided, all fields defined in the class will be included, as well as inherited ones following the mro.</li> <li><code>post_init_fun</code>: (default: <code>None</code>) an optional function to call once all fields have been initialized. This function should have <code>self</code> as first argument. The rest of its signature will be blended with the fields in the generated constructor signature.</li> <li><code>post_init_args_before</code>: boolean. Defines if the arguments from the <code>post_init_fun</code> should appear before (default: <code>True</code>) or after (<code>False</code>) the fields in the generated signature. Of course in all cases, mandatory arguments will appear after optional arguments, so as to ensure that the created signature is valid.</li> </ul> <p>Outputs: a constructor method to be used as <code>__init__</code></p>"},{"location":"api_reference/#init_fields","title":"<code>@init_fields</code>","text":"<pre><code>def init_fields(*fields: Union[Field, Any],\n                init_args_before: bool = True\n                ):\n</code></pre> <p>Decorator for an init method, so that fields are initialized before entering the method.</p> <p>By default, when the decorator is used without arguments or when <code>fields</code> is empty, all fields defined in the class are initialized. Fields inherited from parent classes are included, following the mro. The signature of the init method is modified so that it can receive values for these fields:</p> <pre><code>&gt;&gt;&gt; from pyfields import field, init_fields\n&gt;&gt;&gt; class Wall:\n...     height: int = field(doc=\"Height of the wall in mm.\")\n...     color: str = field(default='white', doc=\"Color of the wall.\")\n...\n...     @init_fields\n...     def __init__(self, msg: str = 'hello'):\n...         print(\"post init ! height=%s, color=%s, msg=%s\" % (self.height, self.color, msg))\n...         self.non_field_attr = msg\n...\n&gt;&gt;&gt; help(Wall.__init__)\nHelp on function __init__ in module pyfields.init_makers:\n&lt;BLANKLINE&gt;\n__init__(self, height: int, msg: str = 'hello', color: str = 'white')\n    The `__init__` method generated for you when you use `@init_fields`\n    or `make_init` with a non-None `post_init_fun` method.\n&lt;BLANKLINE&gt;\n&gt;&gt;&gt; w = Wall(2)\npost init ! height=2, color=white, msg=hello\n</code></pre> <p>The list of fields can be explicitly provided in <code>fields</code>.</p> <p>By default the init arguments will appear before the fields in the signature, wherever possible (mandatory args before mandatory fields, optional args before optional fields). You can change this behaviour by setting <code>init_args_before</code> to <code>False</code>.</p> <p>Parameters:</p> <ul> <li><code>fields</code>: list of fields to initialize before entering the decorated <code>__init__</code> method. For each of these fields a corresponding argument will be added in the method's signature. If an empty list is provided, all fields from the class will be used including inherited fields following the mro.</li> <li><code>init_args_before</code>: If set to <code>True</code> (default), arguments from the decorated init method will appear before the fields when possible. If set to <code>False</code> the contrary will happen.</li> </ul>"},{"location":"api_reference/#inject_fields","title":"<code>@inject_fields</code>","text":"<pre><code>def inject_fields(*fields: Union[Field, Any],\n                  ):\n</code></pre> <p>A decorator for <code>__init__</code> methods, to make them automatically expose arguments corresponding to all <code>*fields</code>. It can be used with or without arguments. If the list of fields is empty, it means \"all fields from the class\".</p> <p>The decorated <code>__init__</code> method should have an argument named <code>'fields'</code>. This argument will be injected with an object so that users can manually execute the fields initialization. This is done with <code>fields.init()</code>.</p> <pre><code>&gt;&gt;&gt; from pyfields import field, inject_fields\n&gt;&gt;&gt; class Wall(object):\n...     height = field(doc=\"Height of the wall in mm.\")\n...     color = field(default='white', doc=\"Color of the wall.\")\n...\n...     @inject_fields(height, color)\n...     def __init__(self, fields):\n...         # initialize all fields received\n...         fields.init(self)\n...\n...     def __repr__(self):\n...         return \"Wall&lt;height=%r, color=%r&gt;\" % (self.height, self.color)\n...\n&gt;&gt;&gt; Wall()\nTraceback (most recent call last):\n...\nTypeError: __init__() missing 1 required positional argument: 'height'\n&gt;&gt;&gt; Wall(1)\nWall&lt;height=1, color='white'&gt;\n</code></pre> <p>Parameters:</p> <ul> <li><code>fields</code>: list of fields to initialize before entering the decorated <code>__init__</code> method. For each of these fields a corresponding argument will be added in the method's signature. If an empty list is provided, all fields from the class will be used including inherited fields following the mro.</li> </ul>"},{"location":"api_reference/#autofields","title":"<code>@autofields</code>","text":"<pre><code>def autofields(check_types=False,         # type: bool\n               include_upper=False,       # type: bool\n               include_dunder=False,      # type: bool\n               exclude=DEFAULT_EXCLUDED,  # type: Iterable[str]\n               make_init=True             # type: bool\n               ):\n</code></pre> <p>Decorator to automatically create fields and constructor on a class.</p> <p>When a class is decorated with <code>@autofields</code>, all of its members are automatically transformed to fields. More precisely: members that only contain a type annotation become mandatory fields, while members that contain a value (with or without type annotation) become optional fields with a <code>copy_value</code> default_factory.</p> <p>By default, the following members are NOT transformed into fields:</p> <ul> <li>members with upper-case names. This is because this kind of name formatting usually denotes class constants. They    can be transformed to fields by setting <code>include_upper=True</code>.</li> <li>members with dunder-like names. They can be included using <code>include_dunder=True</code>. Note that reserved python    dunder names such as <code>__name__</code>, <code>__setattr__</code>, etc. can not be transformed to fields, even when    <code>include_dunder=True</code>.</li> <li>members that are classes or methods defined in the class (that is, where their <code>.__name__</code> is the same name than    the member name).</li> <li>members that are already fields. Therefore you can continue to use <code>field()</code> on certain members explicitly if    you need to add custom validators, converters, etc.</li> </ul> <p>All created fields have their <code>type_hint</code> filled with the type hint associated with the member, and have <code>check_type=False</code> by default. This can be changed by setting <code>check_types=True</code>.</p> <p>Finally, in addition, an init method (constructor) is generated for the class, using <code>make_init()</code>. This may be disabled by setting <code>make_init=False</code>.</p> <pre><code>&gt;&gt;&gt; @autofields\n... class Pocket:\n...     SENTENCE = \"hello world\"  # uppercase: not a field\n...     size: int   # mandatory field\n...     items = []  # optional - default value will be a factory\n...\n&gt;&gt;&gt; p = Pocket(size=10)\n&gt;&gt;&gt; p.items\n[]\n&gt;&gt;&gt; Pocket(size=10, SENTENCE=\"hello\")\nTraceback (most recent call last):\n...\nTypeError: __init__() got an unexpected keyword argument 'SENTENCE'\n</code></pre> <p>Parameters</p> <ul> <li> <p><code>check_types</code>: boolean flag (default: <code>False</code>) indicating the value of <code>check_type</code> for created fields. Note that the type hint of each created field is copied from the type hint of the member it originates from.</p> </li> <li> <p><code>include_upper</code>: boolean flag (default: <code>False</code>) indicating whether upper-case class members should be also  transformed to fields (usually such names are reserved for class constants, not for fields).</p> </li> <li> <p><code>include_dunder</code>: boolean flag (default: <code>False</code>) indicating whether dunder-named class members should be also transformed to fields. Note that even if you set this to True, members with reserved python dunder names will not be transformed. See <code>is_reserved_dunder</code> for the list of reserved names.</p> </li> <li> <p><code>exclude</code>: a tuple of field names that should be excluded from automatic creation. By default this is set to <code>DEFAULT_EXCLUDED</code>, which eliminates fields created by <code>ABC</code>. </p> </li> <li> <p><code>make_init</code>: boolean flag (default: <code>True</code>) indicating whether a constructor should be created for the class if no <code>__init__</code> method is present. Such constructor will be created using <code>__init__ = make_init()</code>.</p> </li> </ul>"},{"location":"api_reference/#autoclass","title":"<code>@autoclass</code>","text":"<pre><code>def autoclass(\n        # --- autofields\n        fields=True,              # type: Union[bool, DecoratedClass]\n        typecheck=False,          # type: bool\n        # --- constructor\n        init=True,                # type: bool\n        # --- class methods\n        dict=True,                # type: bool\n        dict_public_only=True,    # type: bool\n        repr=True,                # type: bool\n        repr_curly_mode=False,    # type: bool\n        repr_public_only=True,    # type: bool\n        eq=True,                  # type: bool\n        eq_public_only=False,     # type: bool\n        hash=True,                # type: bool\n        hash_public_only=False,   # type: bool\n        # --- advanced\n        af_include_upper=False,   # type: bool\n        af_include_dunder=False,  # type: bool\n        af_exclude=DEFAULT_EXCLUDED,  # type: Iterable[str] \n        ac_include=None,          # type: Union[str, Tuple[str]]\n        ac_exclude=None,          # type: Union[str, Tuple[str]]\n    ):\n</code></pre> <p>A decorator to automate many things at once for your class.</p> <p>First if <code>fields=True</code> (default) it executes <code>@autofields</code> to generate fields from attribute defined at class level.</p> <ul> <li>you can include attributes with dunder names or uppercase names with <code>af_include_dunder</code> and    <code>af_include_upper</code> respectively</li> <li>you can enable type checking on all fields at once by setting <code>check_types=True</code></li> <li>the constructor is not generated at this stage</li> </ul> <p>Then it generates methods for the class:</p> <ul> <li>if <code>init=True</code> (default) it generates the constructor based on all fields present, using <code>make_init()</code>.</li> <li>if <code>dict=True</code> (default) it generates <code>to_dict</code> and <code>from_dict</code> methods. Only public fields are represented in <code>to_dict</code>, you can change this with <code>dict_public_only=False</code>.</li> <li>if <code>repr=True</code> (default) it generates a <code>__repr__</code> method. Only public fields are represented, you can change this with <code>repr_public_only=False</code>.</li> <li>if <code>eq=True</code> (default) it generates an <code>__eq__</code> method, so that instances can be compared to other instances and to dicts. All fields are compared by default, you can change this with <code>eq_public_only=True</code>.</li> <li>if <code>hash=True</code> (default) it generates an <code>__hash__</code> method, so that instances can be inserted in sets or dict keys. All fields are hashed by default, you can change this with <code>hash_public_only=True</code>.</li> </ul> <p>You can specify an explicit list of fields to include or exclude in the dict/repr/eq/hash methods with the <code>ac_include</code> and <code>ac_exclude</code> parameters.</p> <p>Note that this decorator is similar to the autoclass library but is reimplemented here. In particular the parameter names and dictionary behaviour are different.</p> <p>Parameters</p> <ul> <li><code>fields</code>: boolean flag (default: True) indicating whether to create fields automatically. See <code>@autofields</code> for details</li> <li><code>typecheck</code>: boolean flag (default: False) used when fields=True indicating the value of <code>check_type</code> for created fields. Note that the type hint of each created field is copied from the type hint of the member it originates from.</li> <li><code>init</code>: boolean flag (default: True) indicating whether a constructor should be created for the class if no <code>__init__</code> method is already present. Such constructor will be created using <code>__init__ = make_init()</code>. This is the same behaviour than <code>make_init</code> in <code>@autofields</code>. Note that this is not automatically disabled if you set <code>fields=False</code>.</li> <li><code>dict</code>: a boolean to automatically create <code>cls.from_dict(dct)</code> and <code>obj.to_dict()</code> methods on the class (default: True).</li> <li><code>dict_public_only</code>: a boolean (default: True) to indicate if only public fields should be exposed in the dictionary view created by <code>to_dict</code> when <code>dict=True</code>.</li> <li><code>repr</code>: a boolean (default: True) to indicate if <code>__repr__</code> and <code>__str__</code> should be created for the class if not explicitly present.</li> <li><code>repr_curly_mode</code>: a boolean (default: False) to turn on an alternate string representation when <code>repr=True</code>, using curly braces.</li> <li><code>repr_public_only</code>: a boolean (default: True) to indicate if only public fields should be exposed in the string representation when <code>repr=True</code>.</li> <li><code>eq</code>: a boolean (default: True) to indicate if <code>__eq__</code> should be created for the class if not explicitly present.</li> <li><code>eq_public_only</code>: a boolean (default: False) to indicate if only public fields should be  compared in the equality method created when <code>eq=True</code>.</li> <li><code>hash</code>: a boolean (default: True) to indicate if <code>__hash__</code> should be created for the class if not explicitly present.</li> <li><code>hash_public_only</code>: a boolean (default: False) to indicate if only public fields should be hashed in the hash method created when <code>hash=True</code>.</li> <li><code>af_include_upper</code>: boolean flag (default: False) used when autofields=True indicating whether upper-case class members should be also transformed to fields (usually such names are reserved for class constants, not for fields).</li> <li><code>af_include_dunder</code>: boolean flag (default: False) used when autofields=True indicating whether dunder-named class members should be also transformed to fields. Note that even if you set this to True, members with reserved python dunder names will not be transformed. See <code>is_reserved_dunder</code> for the list of reserved names.</li> <li><code>af_exclude</code>: a tuple of explicit attribute names to exclude from automatic fields creation. See <code>@autofields(exclude=...)</code> for details.</li> <li><code>ac_include</code>: a tuple of explicit attribute names to include in dict/repr/eq/hash (None means all)</li> <li><code>ac_exclude</code>: a tuple of explicit attribute names to exclude in dict/repr/eq/hash. In such case, include should be None.</li> </ul>"},{"location":"api_reference/#api","title":"API","text":""},{"location":"api_reference/#has_fields","title":"<code>has_fields</code>","text":"<pre><code>def has_fields(cls,\n               include_inherited=True  # type: bool\n               )\n</code></pre> <p>Returns True if class <code>cls</code> defines at least one <code>pyfields</code> field. If <code>include_inherited</code> is <code>True</code> (default), the method will return <code>True</code> if at least a field is defined in the class or one of its ancestors. If <code>False</code>, the fields need to be defined on the class itself.</p>"},{"location":"api_reference/#get_fields","title":"<code>get_fields</code>","text":"<pre><code>def get_fields(cls_or_obj,\n               include_inherited=True,  # type: bool\n               remove_duplicates=True,  # type: bool\n               ancestors_first=True,    # type: bool\n               public_only=False,       # type: bool\n               container_type=tuple,    # type: Type[T]\n               )\n</code></pre> <p>Utility method to collect all fields defined in a class, including all inherited or not, in definition order. By default duplicates are removed and ancestor fields are included and appear first. If a field is overridden, it will appear at the position of the overridden field in the order.</p> <p>If an object is provided, <code>getfields</code> will be executed on its class.</p>"},{"location":"api_reference/#yield_fields","title":"<code>yield_fields</code>","text":"<pre><code>def yield_fields(cls,\n                 include_inherited=True,  # type: bool\n                 remove_duplicates=True,  # type: bool\n                 ancestors_first=True,    # type: bool\n                 public_only=False,       # type: bool\n                 )\n</code></pre> <p>Similar to <code>get_fields</code> but as a generator.</p>"},{"location":"api_reference/#get_field","title":"<code>get_field</code>","text":"<pre><code>def get_field(cls, name)\n</code></pre> <p>Utility method to return the field member with name <code>name</code> in class <code>cls</code>. If the member is not a field, a <code>NotAFieldError</code> is raised.</p>"},{"location":"api_reference/#get_field_values","title":"<code>get_field_values</code>","text":"<pre><code>def get_field_values(obj,\n                     include_inherited=True,  # type: bool\n                     remove_duplicates=True,  # type: bool\n                     ancestors_first=True,    # type: bool\n                     public_only=False,       # type: bool\n                     container_type=ODict,    # type: Type[T]\n                     )\n</code></pre> <p>Utility method to collect all field names and values defined on an object, including all inherited or not.</p> <p>By default duplicates are removed and ancestor fields are included and appear first. If a field is overridden, it will appear at the position of the overridden field in the order.</p> <p>The result is an ordered dictionary (a <code>dict</code> in python 3.7, an <code>OrderedDict</code> otherwise) of {name: value} pairs. One can change the container type with the <code>container_type</code> attribute though, that will receive an iterable of (key, value) pairs.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#172-bugfix","title":"1.7.2 - bugfix","text":"<ul> <li>Fixed <code>TypeError: Neither typeguard not pytypes is installed</code> even with <code>typeguard</code> installed.     Fixed [#91] (https://github.com/smarie/python-pyfields/issues/91)</li> </ul>"},{"location":"changelog/#171-compatibility-fix-for-typeguard-300","title":"1.7.1 - Compatibility fix for typeguard <code>3.0.0</code>","text":"<ul> <li>Fixed <code>TypeError: check_type() takes 2 positional arguments but 3 were given</code> triggering erroneous <code>FieldTypeError</code>     when <code>typeguard&gt;=3.0.0</code> is used. Fixed #87</li> </ul>"},{"location":"changelog/#170-better-support-for-non-deep-copiable-default-values-in-autofields","title":"1.7.0 - Better support for non-deep-copiable default values in <code>@autofields</code>","text":"<ul> <li> <p><code>@autofields</code> and <code>@autoclass</code> now raise an error when a field definition can not be valid, because the default value can not be deep-copied. This will help users detect issues such as #84 earlier. Implementation is done through a new <code>autocheck</code> option in the <code>copy_value</code> factory.</p> </li> <li> <p><code>@autofields</code> and <code>@autoclass</code> now provide an <code>exclude</code> (resp. <code>af_exclude</code>) list, to list names for fields that should not be created. By default this contains a reserved name from <code>abc.ABCMeta</code>, for convenience. Fixes #84.</p> </li> </ul>"},{"location":"changelog/#162-cicd-migration","title":"1.6.2 - CI/CD migration","text":"<ul> <li>This is a technical release with no code change, to validate the new Github Actions workflow.</li> </ul>"},{"location":"changelog/#161-bugfix","title":"1.6.1 - Bugfix","text":"<ul> <li>Fixed an issue with <code>autofields</code> (and therefore <code>autoclass</code> too) where a field would be mistakenly recreated on a subclass when that subclass does not define type hints while the parent class defines type hints. Fixes #81</li> </ul>"},{"location":"changelog/#160-we-now-have-our-own-version-of-autoclass","title":"1.6.0 - we now have our own version of <code>@autoclass</code>","text":"<ul> <li>Copied the relevant contents from <code>autoclass</code> so as to get rid of the dependency. Since we are in a <code>pyfields</code> context there were many things that could be dropped and remaining code could be easily copied over. Also took this opportunity to replace the dict view with a <code>to_dict</code>/<code>from_dict</code> pair of methods, this seems less intrusive in the class design. Finally the parameter names have been simplified, see API reference for details. Fixes #79</li> </ul>"},{"location":"changelog/#150-updated-autoclass-signature","title":"1.5.0 - updated <code>@autoclass</code> signature","text":"<ul> <li>Improved <code>@autoclass</code> so that it is much easier to access the relevant arguments from underlying <code>@autofields</code> and <code>@autoclass</code>. Fixed #78</li> </ul>"},{"location":"changelog/#140-new-autoclass-decorator","title":"1.4.0 - new <code>@autoclass</code> decorator","text":"<ul> <li>New <code>@autoclass</code> decorator directly available from <code>pyfields</code>. It is merely equivalent to the original <code>@autoclass</code> with option <code>autofields=True</code>, which makes it easier to use on classes with automatic fields. Fixes #75</li> </ul>"},{"location":"changelog/#132-bugfix","title":"1.3.2 - bugfix","text":"<ul> <li>Fields order are preserved by <code>@autofields</code> even in the case of an explicit <code>field()</code> with all others implicit. Fixed #77</li> </ul>"},{"location":"changelog/#131-bugfix","title":"1.3.1 - bugfix","text":"<ul> <li>Fields order are preserved by <code>@autofields</code> even in the case of a field with just a type annotation. Fixed #76</li> </ul>"},{"location":"changelog/#130-support-for-forward-references-pep563-and-class-level-access","title":"1.3.0 - Support for Forward references, PEP563 and class-level access","text":"<ul> <li> <p>String forward references in type hints, and PEP563 behaviour, is now supported. When this case happense, the type hint resolution is delayed until the field is first accessed. Fixes #73</p> </li> <li> <p>Accessing a field definition from a class directly is now enabled, since PyCharm fixed their autocompletion bug. Fixes #12</p> </li> </ul>"},{"location":"changelog/#120-getfields-improvements-and-new-get_field_values","title":"1.2.0 - <code>getfields</code> improvements and new <code>get_field_values</code>","text":"<ul> <li> <p><code>getfields</code> can now be executed on an instance, and provides a <code>public_only</code> option. Fixes #69</p> </li> <li> <p>New <code>get_field_values</code> method to get an ordered dict-like of field name: value.  Fixes #70</p> </li> </ul>"},{"location":"changelog/#115-bugfix","title":"1.1.5 - bugfix","text":"<ul> <li><code>@autofields</code> now correctly skips <code>@property</code> and more generally, descriptor members. Fixes #67</li> </ul>"},{"location":"changelog/#114-better-python-2-packaging","title":"1.1.4 - better python 2 packaging","text":"<ul> <li>packaging improvements: set the \"universal wheel\" flag to 1, and cleaned up the <code>setup.py</code>. In particular removed dependency to <code>six</code>. Fixes #66</li> </ul>"},{"location":"changelog/#113-smaller-wheel","title":"1.1.3 - smaller wheel","text":"<ul> <li><code>tests</code> folder is now excluded from generated package wheel. Fixed #65</li> </ul>"},{"location":"changelog/#112-type-hint-fix-minor","title":"1.1.2 - type hint fix (minor)","text":"<ul> <li>Now <code>converters={'*': ...}</code> does not appear as a type hint error. Fixed #64</li> </ul>"},{"location":"changelog/#111-pep561-compatibility","title":"1.1.1 - PEP561 compatibility","text":"<ul> <li>Misc: Package is now PEP561 compatible. Fixed #61</li> </ul>"},{"location":"changelog/#110-autofields-and-default-values-improvements","title":"1.1.0 - @autofields and default values improvements","text":"<ul> <li> <p>New <code>@autofields</code> decorator. This decorator can be used to drastically reduce boilerplate code, similar to <code>pydantic</code> and <code>attrs</code>. This is compliant with python 2.7 and 3.5+ but is more useful when the type hints can be provided in class member annotations, so from 3.6+. Fixed #55</p> </li> <li> <p>Default values are now validated/converted as normal values. If the default value is provided in <code>default=&lt;value&gt;</code> or as a <code>default_factory=copy_value(&lt;value&gt;)</code>, this is done only once per field, to accelerate future access. If the value was converted on the way, the converted value is used to replace the default value, or the default value copied by the factory. Fixed #57</p> </li> <li> <p>Misc: removed <code>makefun</code> usage in <code>validate_n_convert.py</code> : was overkill. Also fixed a few type hints.</p> </li> </ul>"},{"location":"changelog/#103-bugfix","title":"1.0.3 - bugfix","text":"<ul> <li>Fixed bug with <code>super().__init__</code> not behaving as expected. Fixed #53</li> </ul>"},{"location":"changelog/#102-bugfixes","title":"1.0.2 - bugfixes","text":"<ul> <li>User-provided <code>nonable</code> status was wrongly overriden automatically when the field was attached to the class. Fixed #51 </li> <li>Fixed an issue with type validation when <code>typeguard</code> is used and a tuple of types is provided instead of a <code>Union</code>. Fixed #52</li> </ul>"},{"location":"changelog/#101-pyprojecttoml","title":"1.0.1 - <code>pyproject.toml</code>","text":"<p>Added <code>pyproject.toml</code></p>"},{"location":"changelog/#100-stable-version","title":"1.0.0 - Stable version","text":"<p>Overall behaviour stabilized and compliance with <code>@autoclass</code> to cover most use cases.</p> <p>The only bug that has not yet been fixed is #12 </p>"},{"location":"changelog/#0140-helpers-bugfix-and-ancestor-first-option-in-init-makers","title":"0.14.0 - helpers, bugfix, and ancestor-first option in init makers","text":"<p>API</p> <ul> <li> <p>new helper methods <code>get_field</code>, <code>yield_fields</code>, <code>has_fields</code> and <code>get_fields</code> (new name of <code>collect_all_fields</code>) so that other libraries such as <code>autoclass</code> can easily access the various information. <code>fix_fields</code> removed. Fixed #48 </p> </li> <li> <p>New <code>ancestor_fields_first</code> option in all the <code>__init__</code> makers (<code>make_init</code> and <code>@init_fields</code>). Fixed #50</p> </li> </ul> <p>Bugfixes</p> <ul> <li> <p>Bugfixes in all the <code>__init__</code> makers (<code>make_init</code> and <code>@init_fields</code>):  </p> <ul> <li> <p>bugfix in case of inheritance with override: #49</p> </li> <li> <p>the argument order used for fields initialization (inside the generated init method body) was sometimes incorrect. This would trigger a bug when one field was requiring another one to initialize.</p> </li> <li> <p>when the list of fields received by <code>InitDescriptor</code> was an empty tuple and not <code>None</code>, the constructor was not created properly</p> </li> </ul> </li> </ul>"},{"location":"changelog/#0130-nonable-fields","title":"0.13.0 - <code>nonable</code> fields","text":"<ul> <li>Fields can now be <code>nonable</code>, so as to bypass type and value validation when <code>None</code> is received. Fixed #44</li> </ul>"},{"location":"changelog/#0120-minor-improvements","title":"0.12.0 - Minor improvements","text":"<ul> <li>Now all type validation errors are <code>FieldTypeError</code>. Fixed #40.</li> <li>Fixed bug with python &lt; 3.6 where fields were not automatically attached to their class when used from within a subclass first. Fixed #41</li> </ul>"},{"location":"changelog/#0110-better-initialization-orders-in-generated-__init__","title":"0.11.0 - Better initialization orders in generated <code>__init__</code>","text":"<p>Fixed fields initialization order in generated constructor methods:</p> <ul> <li>the order is now the same than the order of appearance in the class (and not reversed as it was). Fixed #36. </li> <li>the above is true, even in python &lt; 3.6. Fixed #38</li> <li>the order now takes into account first the ancestors and then the subclasses, for the most intuitive behaviour. Fixed #37.</li> </ul>"},{"location":"changelog/#0100-read-only-fields-minor-improvements","title":"0.10.0 - Read-only fields + minor improvements","text":"<p>Read-only fields</p> <ul> <li>Read-only fields are now supported through <code>field(read_only=True)</code>. Fixes #33.</li> </ul> <p>Misc</p> <ul> <li>All core exceptions now derive from a common <code>FieldError</code>, for easier exception handling. </li> <li>Now raising an explicit <code>ValueError</code> when a descriptor field is used with an old-style class in python 2. Fixes #34 </li> </ul>"},{"location":"changelog/#091-minor-improvements","title":"0.9.1 - Minor improvements","text":"<ul> <li>Minor performance improvement: <code>Converter.create_from_fun()</code> does not generate a new <code>type</code> everytime a converter needs to be created from a callable - now a single class <code>ConverterWithFuncs</code> is used. Fixed #32. </li> </ul>"},{"location":"changelog/#090-converters","title":"0.9.0 - Converters","text":"<p>converters</p> <ul> <li>Fields can now be equipped with converters by using <code>field(converters=...)</code>. Fixes #5</li> <li>New method <code>trace_convert</code> to debug conversion issues. It is available both as an independent function and as a method on <code>Field</code>. Fixes #31</li> <li>New decorator <code>@&lt;field&gt;.converter</code> to add a converter to a field. Fixed #28.</li> </ul> <p>misc</p> <ul> <li>The base <code>Field</code> class is now exposed at package level.</li> </ul>"},{"location":"changelog/#080-pep484-support","title":"0.8.0 - PEP484 support","text":"<p>PEP484 type hints support</p> <ul> <li>Now type hints relying on the <code>typing</code> module (PEP484) are correctly checked using whatever 3d party type checking library is available (<code>typeguard</code> is first looked for, then <code>pytypes</code> as a fallback). If none of these providers are available, a fallback implementation is provided, basically flattening <code>Union</code>s and replacing <code>TypeVar</code>s before doing <code>is_instance</code>. It is not guaranteed to support all <code>typing</code> subtelties. Fixes #7</li> </ul>"},{"location":"changelog/#070-more-ways-to-define-validators","title":"0.7.0 - more ways to define validators","text":"<p>validators</p> <ul> <li>New decorator <code>@&lt;field&gt;.validator</code> to add a validator to a field. Fixed #9. </li> <li>Native fields are automatically transformed into descriptor fields when validators are added this way. Fixes #1.</li> </ul>"},{"location":"changelog/#060-default-factories-and-slots","title":"0.6.0 - default factories and slots","text":"<p>default value factories</p> <ul> <li><code>default_factory</code> callables now receive one argument: the object instance. Fixes #6</li> <li>New decorator <code>@&lt;field&gt;.default_factory</code> to define a default value factory. Fixed #27</li> <li>New <code>copy_value</code>, <code>copy_field</code> and <code>copy_attr</code> helper functions to create default value factories. Fixed #26</li> </ul> <p>support for slots</p> <ul> <li><code>field</code> now automatically detects when a native field is attached to a class with slots and no <code>__dict__</code> is present. In that case, the native field is replaced with a descriptor field. Fixed #20.</li> </ul>"},{"location":"changelog/#050-first-public-version","title":"0.5.0 - First public version","text":"<p>fields</p> <ul> <li> <p><code>field()</code> method to easily define class fields without necessarily defining a <code>__init__</code>.</p> </li> <li> <p>\"native\" fields are created by default, or if <code>native=True</code> is set. A <code>NativeField</code> is a non-data descriptor that replaces itself automatically with a native python attribute after the first read, to get the same performance level on later access. </p> </li> <li> <p>\"descriptor\" fields are created when type or value validation is required, or if <code>native=False</code> is set. A <code>DescriptorField</code> uses the standard python descriptor protocol so that type and value can be validated on all future access without messing with the <code>__setattr__</code> method.</p> </li> <li> <p>support for <code>type_hint</code> declaration to declare the type of a field. If <code>validate_type</code> provided, the descriptor will not be replaced with a native field, and the type will be checked on every value modification. A <code>TypeError</code> will be raised if type does not comply. Type hints are correctly defined so that IDEs can pick them. Fixes #10</p> </li> <li> <p>support for <code>validators</code> relying on <code>valid8</code>. Validators can receive <code>(val)</code>, <code>(obj, val)</code> or <code>(obj, field, val)</code> to support validation based on several fields. The only requirement is to return <code>True</code> or <code>None</code> in case of success. Fixes #3</p> </li> </ul> <p>init</p> <ul> <li> <p><code>make_init</code> method to create an entire <code>__init__</code> method with control of which fields are injected, and with possibility to blend a post-init callback in. Fixes #14.</p> </li> <li> <p><code>@init_fields</code> decorator to auto-init fields before your <code>__init__</code> method.</p> </li> <li> <p><code>@inject_fields</code> decorator to easily inject <code>fields</code> in an init method and perform the assignment precisely when users want (for easy debugging). Fixes #13</p> </li> </ul> <p>misc</p> <ul> <li> <p><code>__weakref__</code> added in all relevant classes. Fixes #21</p> </li> <li> <p>Now using stubs #17</p> </li> <li> <p>Fixed bug #11.</p> </li> <li> <p>Fixed <code>ValueError</code> with mini-lambda &lt; 2.2. Fixed #22</p> </li> <li> <p>Because of a limitation in PyCharm type hints we had to remove support for class-level field access. This created #12 which will be fixed as soon as PyCharm issue is fixed.</p> </li> </ul>"},{"location":"changelog/#010-unpublished-first-draft","title":"0.1.0 - unpublished first draft","text":"<p>Extracted from <code>mixture</code>.</p>"},{"location":"long_description/","title":"python-pyfields","text":"<p>Define fields in python classes. Easily.</p> <p> </p> <p> </p> <p>The documentation for users is available here: https://smarie.github.io/python-pyfields/</p> <p>A readme for developers is available here: https://github.com/smarie/python-pyfields</p>"},{"location":"why/","title":"Why <code>pyfields</code> ?","text":"<p>During the few years I spent exploring the python world, I tried several times to find a \"good\" way to create classes where fields could be </p> <ul> <li>declared explicitly in a compact way</li> <li>with optional validation and conversion</li> <li>with as little call overhead as possible</li> <li>without messing with the <code>__init__</code> and <code>__setattr__</code> methods</li> </ul> <p>I discovered:</p> <ul> <li> <p><code>@property</code>, that is a good start but adds a python call cost on access and lacks the possibility to add validation and conversion in a compact declaration. It relies on the generic python descriptors mechanism.</p> </li> <li> <p><code>attrs</code>, a great way to define classes with many out-of-the-box features (representation, hashing, constructor, ...). Its philosophy is that objects should be immutable (They can be mutable, actually they are by default, but the validators are not executed on value modification as of 0.19). The way it works is by creating a \"smart\"  <code>__init__</code> script that contains all the logic (see here), and possibly a <code>__setattr__</code> if you ask for immutable objects with <code>frozen=True</code>.</p> </li> <li> <p><code>autoclass</code> was one of my first open-source projects in python: I tried to create a less optimized version of <code>attrs</code>, but at least something that would support basic use cases. The main difference with <code>attrs</code> is that fields are defined using the <code>__init__</code> signature, instead of class attributes, and it is possible to define custom setters to perform validation, that are effectively called on value modification. I also developed at the time a validation lib <code>valid8</code>) that works with <code>autoclass</code> and <code>attrs</code>. The result has been used in industrial projects. But it is still not satisfying because relying on the <code>__init__</code> signature to define the fields is not very elegant and flexible in particular in case of multiple inheritance.</p> </li> <li> <p>PEP557 <code>dataclasses</code> was largely inspired by and is roughly equivalent to <code>attrs</code>, although a few design choices differ and its scope seems more limited.</p> </li> </ul> <p>In parallel I discovered a few libraries oriented towards data modelling and serialization:</p> <ul> <li> <p><code>marshmallow</code>, an ORM / ODM / framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes.</p> </li> <li> <p><code>related</code> is also a library oriented towards converting data models from/to json/yaml/python</p> </li> <li> <p><code>colander</code></p> </li> <li> <p><code>django</code> forms</p> </li> </ul> <p>This topic was left aside for a moment, until half 2019 where I thought that I had accumulated enough python expertise (with <code>makefun</code>, <code>decopatch</code> and many pytest libraries) to have a fresh look on it. In the meantime I had discovered:</p> <ul> <li> <p><code>traitlets</code> which provides a quite elegant way to define typed fields and define validation, but requires the classes to inherit from <code>HasTraits</code>, and does not allow users to define converters.</p> </li> <li> <p><code>traits</code></p> </li> <li> <p>werkzeug's <code>@cached_property</code> and sagemath's <code>@lazy_attribute</code>, that both rely on the descriptor protocol to define class fields, but lack compacity</p> </li> <li> <p><code>zopeinterface</code>, targeting definition of strict interfaces (but including attributes in their definition). It also defines the concept of \"invariants\"</p> </li> <li> <p><code>pydantic</code> embraces python 3.6+ type hints (that can be defined on class attributes). It is quite elegant, is compliant with <code>dataclasses</code>, and supports validators that can act on single or multiple fields. It requires classes to inherit from a <code>BaseModel</code>. It does not seem to support converters as of version 0.32, rather, some type conversion happens behind the scenes (see for example this issue). But it looks definitely promising.</p> </li> <li> <p><code>trellis</code> which provides an event-driven framework for class attributes with linked effects</p> </li> </ul> <p>I was still not satisfied by the landscape :(. So I wrote this alternative, maybe it can fit in some use cases ! Do not hesitate to provide feedback in the issues page.</p>"}]}